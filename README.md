Project Handover: Ubuntu Hacker Simulator

1. Project Overview

Project Name: Ubuntu Hacker Simulator
Platform: Web (Browser-based)
File Structure: Single-File Monolith (.html)

This project is a highly interactive, browser-based simulation of an Ubuntu 24.04 desktop environment customized with a "Hollywood Hacker" aesthetic. It is designed to look like a high-tech cybersecurity workstation. The simulation creates an immersive experience where the user roleplays as a hacker writing kernel code, cracking passwords, and exploiting remote servers.

2. Technical Stack

The project follows a Single-File Mandate for portability and ease of deployment.

HTML5: Structural markup.

CSS3:

Tailwind CSS (via CDN): Used for utility-based styling, layout (Flexbox/Grid), and typography.

Custom CSS: Embedded in the <style> block for specific UI components like the "CRT Scanline" effect, glassmorphism filters, window chrome, and custom scrollbars.

JavaScript (Vanilla): Embedded in the <script> block. Handles all logic, state management, DOM manipulation, and canvas rendering. No external JS frameworks are used.

Icons: FontAwesome (via CDN).

Fonts: Google Fonts (Ubuntu, Fira Code).

3. Core Architecture & Modules

3.1. Desktop Environment

Window Management: A custom implementation allows windows to be:

Dragged: Using the title bar header.

Resized: Using a custom handle in the bottom-right corner.

Focused: Clicking a window brings it to the top (z-index manipulation).

Closed: Hides the DOM element (simulated close).

System UI: Includes a top bar with a functional clock and an interactive system menu (Network/Volume/Battery) that toggles a Quick Settings dropdown.

Dock & App Grid: A side dock launches apps. The bottom button triggers a full-screen "Activities" app grid overlay.

3.2. Terminal 1: The "Coding" Simulator

Purpose: Simulates the preparation phase.

Mechanism: "Hacker Typer" logic.

Listens for keydown events.

Prevents default input.

Appends a predefined chunk of C code (sourceCodeBuffer) regardless of what key is pressed.

State Machine:

Coding Phase: Types out bruteforce_v9.c.

Prompt Phase: Switches to a shell prompt.

Compile Phase: Simulates typing the gcc command.

Build Phase: displays fake compilation logs (linking objects, optimization) before finishing.

3.3. Tool: BruteForce Decryptor v9

Purpose: The "Mini-game" to obtain the root key.

Mechanism:

Dirty Logs: Generates chaotic, verbose logs (memory dumps, hex codes, segfaults) to simulate a heavy process.

The "Luck" Mechanic: Success is NOT based on the input text. It is based on the timestamp when the "EXECUTE" button is clicked.

Logic: if (Date.now() % 3 === 0) -> Success. This gives a ~33% success rate.

Success State: Generates a random global key (stored in systemRootKey) and displays it to the user.

3.4. Terminal 2: The Exploit Launcher

Purpose: The execution phase.

Mechanism: A functional shell simulation.

Parses commands typed by the user (e.g., ./autohack.sh --key X).

Key Validation: Checks the user input against the global systemRootKey generated by the Decryptor.

Flow:

Initialization: Always runs a "connecting/analyzing" sequence.

Flood: Runs a visual "packet flood" animation (faster logs).

Result: Grants access if the key matches; denies access and floods error logs if the key is wrong.

3.5. Terminal 3: Server Root (Post-Exploit)

Trigger: Opens automatically only after a successful hack in Terminal 2.

Purpose: Simulates the "prize."

Mechanism: Similar to Terminal 1, typing here generates fake SQL queries and database dumps (SHOW DATABASES, SELECT * FROM users, etc.).

3.6. System Monitor

Tech: HTML5 <canvas>.

Logic: Two LineGraph class instances render CPU and Memory usage.

Update Rate: Updates every 2000ms (2 seconds) for a slow, deliberate pacing.

4. Key Global Variables

To maintain state across the distinct "windows," the following global variables are used:

systemRootKey: Initially null. Populated by the BruteForce Decryptor upon a successful crack. Consumed by Terminal 2 to validate the exploit.

zIndexCounter: Incremented every time a window is clicked to ensure the active window is always on top.

autoScriptRunning: Boolean flag to prevent multiple scripts from running simultaneously in the terminals.

5. User Journey / Usage Instructions

To demonstrate the full capability of the simulator:

Open Terminal 1: Type randomly to write the C code and "compile" the tool.

Open Decryptor: Enter any text in the key field and click "EXECUTE."

Hint: Keep clicking until you get a "MATCH" (purple log line MOD=0).

Result: Note the green key displayed (e.g., ROOT-A1B2C3).

Open Terminal 2: Type ./autohack.sh --key [THE_KEY_FROM_STEP_2].

Wait: Watch the flood sequence.

Win: The "Server Root" terminal will open automatically. Type there to dump the database.

6. Maintenance Notes

Modifying Logs: Look for the arrays failLogs, preFloodMsgs, etc., in the script section to change the text output.

Adjusting Difficulty: To make the Decryptor harder/easier, modify the mod3 check in the attemptDecrypt function (e.g., Date.now() % 5 === 0 for 20% chance).

Performance: The logs can generate many DOM elements. The code currently does not cap the scrollback buffer significantly, but scrollTop handling keeps it visually performant.

7. Known Behaviors

Indentation: The Terminal HTML is compacted to prevent white-space: pre-wrap from rendering indentation spaces in the source code as visual gaps in the terminal UI.

Resize: Resizing uses a simple DOM manipulation calculation. It does not use the CSS resize property to allow for custom styling of the handle.

Document generated for handover.
